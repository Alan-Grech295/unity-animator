// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel Main
#include "UnityCG.cginc"

struct SphereData
{
    float3 position;
    float radius;
};

struct BoxData
{
    float4x4 transformationInverse;
};

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float4> _Result;
RWTexture2D<float> _Depth;
int _Width;
int _Height;

RWStructuredBuffer<SphereData> _Spheres;
RWStructuredBuffer<BoxData> _Boxes;

float4x4 _CameraToWorld;
float4x4 _CameraInverseProjection;

float _NearClip;
float _FarClip;

#define EPSILON 0.00001f

#define MIN_EPSILON EPSILON
#define MAX_EPSILON 0.01f

struct Ray
{
    float3 origin;
    float3 direction;
};

Ray CreateRay(float3 origin, float3 direction)
{
    Ray ray;
    ray.origin = origin;
    ray.direction = direction;
    return ray;
}

Ray CreateCameraRay(float2 uv)
{
    // Transform the camera origin to world space
    float3 origin = mul(_CameraToWorld, float4(0.0f, 0.0f, 0.0f, 1.0f)).xyz;
    
    // Invert the perspective projection of the view-space position
    float3 direction = mul(_CameraInverseProjection, float4(uv, 0.0f, 1.0f)).xyz;
    // Transform the direction from camera to world space and normalize
    direction = mul(_CameraToWorld, float4(direction, 0.0f)).xyz;
    direction = normalize(direction);

    return CreateRay(origin, direction);
}

float Epsilon(float x)
{
    return lerp(MIN_EPSILON, MAX_EPSILON, x / 10000.0f);
}

float SphereSDF(float3 center, float3 pos, float radius)
{
    return length(center - pos) - radius;
}

float BoxSDF(float3 center, float3 pos, float3 size)
{
    float x = max(pos.x - center.x - size.x / 2.0,
                  center.x - pos.x - size.x / 2.0);
    
    float y = max(pos.y - center.y - size.y / 2.0,
                  center.y - pos.y - size.y / 2.0);
    
    float z = max(pos.z - center.z - size.z / 2.0,
                  center.z - pos.z - size.z / 2.0);
    
    return max(max(x, y), z);
}

float UnitCubeSDF(float3 center, float3 pos)
{
    float x = max(pos.x - center.x - 0.5f,
                  center.x - pos.x - 0.5f);
    
    float y = max(pos.y - center.y - 0.5f,
                  center.y - pos.y - 0.5f);
    
    float z = max(pos.z - center.z - 0.5f,
                  center.z - pos.z - 0.5f);
    
    return max(max(x, y), z);
}

float SmoothMin(float a, float b, float k)
{
    if(k <= 0)
        return min(a, b);
    
    float h = max(k - abs(a - b), 0) / k;
    return min(a, b) - h * h * h * k * 1 / 6.0f;
}

float SegmentSDF(float3 a, float3 b, float3 pos, float thickness)
{
    float3 ab = b - a;
    float3 ap = pos - a;
    
    float t = saturate(dot(ap, ab) / dot(ab, ab));
   
    return length(pos - (a + t * ab)) - thickness;
}

float LinearDepth(float depth)
{
    if(depth == 0)
        return 1;
    
    return pow((0.6822 / depth), 1 / 1.058);
}

float SqrLength(float3 x)
{
    return dot(x, x);
}

float SceneSDF(float3 pos)
{
    uint numSpheres, stride;
    _Spheres.GetDimensions(numSpheres, stride);
    
    uint numBoxes;
    _Boxes.GetDimensions(numBoxes, stride);
    
    float minDist = _FarClip;
    for (int i = 0; i < numSpheres; i++)
    {
        SphereData sphere = _Spheres[i];
        minDist = min(minDist, SphereSDF(sphere.position, pos, sphere.radius));
    }
    
    for (int i = 0; i < numBoxes; i++)
    {
        BoxData box = _Boxes[i];
        
        float4x4 transposed = transpose(box.transformationInverse);
        float4x4 mat = box.transformationInverse;
        
        if (SqrLength(mat[0].xyz) == 0 || SqrLength(mat[1].xyz) == 0 || SqrLength(mat[2].xyz) == 0)
           continue;
        
        float3 boxPos = -transposed[3].xyz;
        minDist = min(minDist, UnitCubeSDF(boxPos, mul(box.transformationInverse, float4(pos.xyz, 0)).xyz));
    }
    
    return minDist;

    // return SmoothMin(SegmentSDF(0, float3(0, 0, 5), pt, 0.5f), SphereSDF(0, pt, 3), 1);
}

float3 SceneNormal(float3 pt)
{
    float2 eps = float2(0, max(max(Epsilon(pt.x), Epsilon(pt.y)), Epsilon(pt.z)));
    return normalize(float3(SceneSDF(pt + eps.yxx) - SceneSDF(pt - eps.yxx),
                                   SceneSDF(pt + eps.xyx) - SceneSDF(pt - eps.xyx),
                                   SceneSDF(pt + eps.xxy) - SceneSDF(pt - eps.xxy)));
                                   
}

[numthreads(8,8,1)]
void Main(uint3 id : SV_DispatchThreadID)
{
    if(id.x >= _Width || id.y >= _Height)
        return;
    
    // Transform pixel to [-1,1] range
    float2 uv = float2((id.xy + float2(0.5f, 0.5f)) / float2(_Width, _Height) * 2.0f - 1.0f);

    // Get a ray for the UVs
    Ray ray = CreateCameraRay(uv);
    
    float maxDist = Linear01Depth(_Depth[id.xy]) * (_FarClip - _NearClip);
    
    float curDist = 0;
    
    float4 outCol = _Result[id.xy];
    
    for (int i = 0; i < 1000; i++)
    {
        float3 pt = ray.origin + ray.direction * curDist;
        float minDist = SceneSDF(pt);
        
        if (minDist <= EPSILON)
        {
            float3 normal = SceneNormal(pt);
            
            float3 lightDir = float3(0, 1, 0);
            float diffuse = saturate(dot(normal, lightDir));
            
            float specular = pow(saturate(dot(reflect(lightDir, normal), ray.direction)), 2);
            
            outCol = float4(1, 0, 0, 1) * diffuse + specular * 0.5f;
            break;
        }
        
        curDist += minDist;
        
        if (curDist >= maxDist)
        {
            break;
        }
    }
        
    _Result[id.xy] = outCol;
}
