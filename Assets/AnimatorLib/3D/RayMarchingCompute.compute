// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel Main
#include "UnityCG.cginc"

struct SphereData
{
    float3 position;
    float radius;
    int materialIndex;
};

struct BoxData
{
    float3 position;
    float3 scale;
    float4x4 rotationInverse;
    int materialIndex;
};

struct LineSegmentData
{
    float3 Start;
    float3 End;
    float Thickness;
    int MaterialIndex;
};


struct MaterialData
{
    float4 Albedo;
    float Smoothness;
    float SpecularPower;
    float4 Ambient;
    float AmbientStrength;
    float Opacity;
    bool Lit;
};

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float4> _Result;
RWTexture2D<float> _Depth;
int _Width;
int _Height;

RWStructuredBuffer<SphereData> _Spheres;
RWStructuredBuffer<BoxData> _Boxes;
RWStructuredBuffer<LineSegmentData> _LineSegments;
RWStructuredBuffer<MaterialData> _Materials;

float4x4 _CameraToWorld;
float4x4 _CameraInverseProjection;

float _NearClip;
float _FarClip;

#define EPSILON 0.0001f

#define MIN_EPSILON 0.0001f
#define MAX_EPSILON 0.01f

#define INNER_STEP 0.01f

#define MAX_TRANSPARENT_INTERSECTIONS 100

struct Ray
{
    float3 origin;
    float3 direction;
};

Ray CreateRay(float3 origin, float3 direction)
{
    Ray ray;
    ray.origin = origin;
    ray.direction = direction;
    return ray;
}

Ray CreateCameraRay(float2 uv)
{
    // Transform the camera origin to world space
    float3 origin = mul(_CameraToWorld, float4(0.0f, 0.0f, 0.0f, 1.0f)).xyz;
    
    // Invert the perspective projection of the view-space position
    float3 direction = mul(_CameraInverseProjection, float4(uv, 0.0f, 1.0f)).xyz;
    // Transform the direction from camera to world space and normalize
    direction = mul(_CameraToWorld, float4(direction, 0.0f)).xyz;
    direction = normalize(direction);

    return CreateRay(origin, direction);
}

float Epsilon(float x)
{
    return lerp(MIN_EPSILON, MAX_EPSILON, x / 10000.0f);
}

float SphereSDF(float3 center, float3 pos, float radius)
{
    return length(center - pos) - radius;
}

float BoxSDF(float3 center, float3 pos, float3 size)
{
    float x = max(pos.x - center.x - size.x / 2.0,
                  center.x - pos.x - size.x / 2.0);
    
    float y = max(pos.y - center.y - size.y / 2.0,
                  center.y - pos.y - size.y / 2.0);
    
    float z = max(pos.z - center.z - size.z / 2.0,
                  center.z - pos.z - size.z / 2.0);
    
    return max(max(x, y), z);
}

float UnitCubeSDF(float3 center, float3 pos)
{    
    float x = max(pos.x - center.x - 0.5f,
                  center.x - pos.x - 0.5f);
    
    float y = max(pos.y - center.y - 0.5f,
                  center.y - pos.y - 0.5f);
    
    float z = max(pos.z - center.z - 0.5f,
                  center.z - pos.z - 0.5f);
    
    return max(max(x, y), z);
}

float SmoothMin(float a, float b, float k)
{
    if(k <= 0)
        return min(a, b);
    
    float h = max(k - abs(a - b), 0) / k;
    return min(a, b) - h * h * h * k * 1 / 6.0f;
}

float SegmentSDF(float3 a, float3 b, float3 pos, float thickness)
{
    float3 ab = b - a;
    float3 ap = pos - a;
    
    float t = saturate(dot(ap, ab) / dot(ab, ab));
   
    return length(pos - (a + t * ab)) - thickness;
}

float LinearDepth(float depth)
{
    if(depth == 0)
        return 1;
    
    return pow((0.6822 / depth), 1 / 1.058);
}

float SqrLength(float3 x)
{
    return dot(x, x);
}

float2 SceneSDF(float3 pos)
{
    uint numSpheres, stride;
    _Spheres.GetDimensions(numSpheres, stride);
    
    float minDist = _FarClip;
    int materialIndex = 0;
    for (int i = 0; i < numSpheres; i++)
    {
        SphereData sphere = _Spheres[i];
        float dist = SphereSDF(sphere.position, pos, sphere.radius);
        if ((dist >= 0 || minDist == _FarClip) && dist < minDist)
        {
            minDist = dist;
            materialIndex = sphere.materialIndex;
        }
    }
    
    uint numBoxes;
    _Boxes.GetDimensions(numBoxes, stride);
    
    for (int i = 0; i < numBoxes; i++)
    {
        BoxData box = _Boxes[i];
        
        if (SqrLength(box.scale) == 0)
           continue;
        
        float3 rotatedPoint = mul(box.rotationInverse, float4(pos.xyz - box.position, 0)).xyz + box.position;
                
        float dist = BoxSDF(box.position, rotatedPoint, box.scale);
        if ((dist > -EPSILON || minDist == _FarClip) && dist < minDist)
        {
            minDist = dist;
            materialIndex = box.materialIndex;
        }
    }
    
    uint numSegments;
    _LineSegments.GetDimensions(numSegments, stride);
    
    for (int i = 0; i < numSegments; i++)
    {
        LineSegmentData segment = _LineSegments[i];
        
        if (segment.Thickness == 0)
            continue;
        
        float dist = SegmentSDF(segment.Start, segment.End, pos.xyz, segment.Thickness);
        if ((dist > -EPSILON || minDist == _FarClip) && dist < minDist)
        {
            minDist = dist;
            materialIndex = segment.MaterialIndex;
        }
    }
    
    return float2(minDist, materialIndex);

    // return SmoothMin(SegmentSDF(0, float3(0, 0, 5), pt, 0.5f), SphereSDF(0, pt, 3), 1);
}

float3 SceneNormal(float3 pt)
{
    float2 eps = float2(0, max(max(Epsilon(pt.x), Epsilon(pt.y)), Epsilon(pt.z)));
    return normalize(float3(SceneSDF(pt + eps.yxx).x - SceneSDF(pt - eps.yxx).x,
                                   SceneSDF(pt + eps.xyx).x - SceneSDF(pt - eps.xyx).x,
                                   SceneSDF(pt + eps.xxy).x - SceneSDF(pt - eps.xxy).x));
                                   
}

float4 GetColor(float3 pos, float3 rayDir, int materialIndex)
{
    MaterialData material = _Materials[materialIndex];
    float3 normal = SceneNormal(pos);
    
    float3 lightDir = float3(0, 1, 0);
    
    float diffuse = material.Lit ? saturate(dot(normal, lightDir)) : 1;
            
    float specular = pow(saturate(dot(reflect(lightDir, normal), rayDir)), material.SpecularPower);
            
    return float4((material.Albedo * diffuse + specular * material.Smoothness + material.Ambient * material.AmbientStrength).xyz, material.Opacity);
}

[numthreads(8,8,1)]
void Main(uint3 id : SV_DispatchThreadID)
{
    if(id.x >= _Width || id.y >= _Height)
        return;
    
    // Transform pixel to [-1,1] range
    float2 uv = float2((id.xy + float2(0.5f, 0.5f)) / float2(_Width, _Height) * 2.0f - 1.0f);

    // Get a ray for the UVs
    Ray ray = CreateCameraRay(uv);
    
    float maxDist = Linear01Depth(_Depth[id.xy]) * (_FarClip - _NearClip);
    
    float curDist = 0;
    
    float4 outCol = _Result[id.xy];
    
    float4 hitCols[MAX_TRANSPARENT_INTERSECTIONS];
    int index = 0;
    
    for (int i = 0; i < 1000; i++)
    {
        float3 pt = ray.origin + ray.direction * curDist;
        float2 sceneData = SceneSDF(pt);
        
        if (abs(sceneData.x) <= EPSILON)
        {            
            float4 col = GetColor(pt, ray.direction, (int) sceneData.y);
            if (col.a > 0)
            {
                hitCols[index] = col;
                index++;
                if (col.a == 1)
                    break;
                
            }
        }
        
        curDist += abs(sceneData.x) >= EPSILON ? abs(sceneData.x) : INNER_STEP;
        
        if (curDist >= maxDist)
        {
            break;
        }
    }
    
    for (int i = index - 1; i >= 0; i--)
    {
        float4 col = hitCols[i];
        outCol = float4(col.rgb * col.a + outCol.rgb * outCol.a * (1 - col.a), 1.0f);
    }
    
    _Result[id.xy] = outCol;
}
