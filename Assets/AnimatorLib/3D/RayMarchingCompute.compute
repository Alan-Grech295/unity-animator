// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel Main
#include "UnityCG.cginc"

struct SphereData
{
    float3 position;
    float radius;
};

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float4> _Result;
RWTexture2D<float> _Depth;
int _Width;
int _Height;

RWStructuredBuffer<SphereData> _Spheres;

float4x4 _CameraToWorld;
float4x4 _CameraInverseProjection;

float _NearClip;
float _FarClip;

static const float EPSILON = 0.00001f;

struct Ray
{
    float3 origin;
    float3 direction;
};

Ray CreateRay(float3 origin, float3 direction)
{
    Ray ray;
    ray.origin = origin;
    ray.direction = direction;
    return ray;
}

Ray CreateCameraRay(float2 uv)
{
    // Transform the camera origin to world space
    float3 origin = mul(_CameraToWorld, float4(0.0f, 0.0f, 0.0f, 1.0f)).xyz;
    
    // Invert the perspective projection of the view-space position
    float3 direction = mul(_CameraInverseProjection, float4(uv, 0.0f, 1.0f)).xyz;
    // Transform the direction from camera to world space and normalize
    direction = mul(_CameraToWorld, float4(direction, 0.0f)).xyz;
    direction = normalize(direction);

    return CreateRay(origin, direction);
}

float SphereSDF(float3 center, float3 pos, float radius)
{
    return length(center - pos) - radius;
}

float SmoothMin(float a, float b, float k)
{
    if(k <= 0)
        return min(a, b);
    
    float h = max(k - abs(a - b), 0) / k;
    return min(a, b) - h * h * h * k * 1 / 6.0f;
}

float SegmentSDF(float3 a, float3 b, float3 pos, float thickness)
{
    float3 ab = b - a;
    float3 ap = pos - a;
    
    float t = saturate(dot(ap, ab) / dot(ab, ab));
   
    return length(pos - (a + t * ab)) - thickness;
}

float LinearDepth(float depth)
{
    if(depth == 0)
        return 1;
    
    return pow((0.6822 / depth), 1 / 1.058);
}

float SceneSDF(float3 pos)
{
    uint numSpheres, stride;
    _Spheres.GetDimensions(numSpheres, stride);
    
    float minDist = _FarClip;
    for (int i = 0; i < numSpheres; i++)
    {
        SphereData sphere = _Spheres[i];
        minDist = min(minDist, SphereSDF(sphere.position, pos, sphere.radius));
    }
    
    return minDist;

    // return SmoothMin(SegmentSDF(0, float3(0, 0, 5), pt, 0.5f), SphereSDF(0, pt, 3), 1);
}

float3 SceneNormal(float3 pt)
{
    static const float2 eps = float2(0, EPSILON);
    return normalize(float3(SceneSDF(pt + eps.yxx) - SceneSDF(pt - eps.yxx),
                                   SceneSDF(pt + eps.xyx) - SceneSDF(pt - eps.xyx),
                                   SceneSDF(pt + eps.xxy) - SceneSDF(pt - eps.xxy)));
                                   
}

[numthreads(8,8,1)]
void Main(uint3 id : SV_DispatchThreadID)
{
    if(id.x >= _Width || id.y >= _Height)
        return;
    
    // Transform pixel to [-1,1] range
    float2 uv = float2((id.xy + float2(0.5f, 0.5f)) / float2(_Width, _Height) * 2.0f - 1.0f);

    // Get a ray for the UVs
    Ray ray = CreateCameraRay(uv);
    
    float maxDist = Linear01Depth(_Depth[id.xy]) * (_FarClip - _NearClip);
    
    float curDist = 0;
    
    float4 outCol = _Result[id.xy];
    
    for (int i = 0; i < 1000; i++)
    {
        float3 pt = ray.origin + ray.direction * curDist;
        float minDist = SceneSDF(pt);
        
        if (minDist <= EPSILON)
        {
            float3 normal = SceneNormal(pt);
            
            float3 lightDir = float3(0, 1, 0);
            float diffuse = saturate(dot(normal, lightDir));
            
            float specular = pow(saturate(dot(reflect(lightDir, normal), ray.direction)), 2);
            
            outCol = float4(1, 0, 0, 1) * diffuse + specular * 0.5f;
            break;
        }
        
        curDist += minDist;
        
        if (curDist >= maxDist)
        {
            break;
        }
    }
        
    _Result[id.xy] = outCol;
}
